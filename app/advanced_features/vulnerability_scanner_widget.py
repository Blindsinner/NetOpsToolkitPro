# app/advanced_features/vulnerability_scanner_widget.py
from __future__ import annotations

import json
import csv
from datetime import datetime
from typing import Dict, List, Optional

from PySide6.QtCore import Qt, QItemSelectionModel, QPoint
from PySide6.QtGui import QColor, QIcon, QClipboard, QAction
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, QLineEdit, QPushButton,
    QGroupBox, QTreeWidget, QTreeWidgetItem, QSplitter,
    QHBoxLayout, QLabel, QCheckBox, QProgressBar, QTextEdit,
    QTabWidget, QToolBar, QFileDialog, QMenu, QMessageBox
)

from app.widgets.base_widget import BaseToolWidget
from app.core.vulnerability_scanner_engine import VulnerabilityScannerEngine


class VulnerabilityScannerWidget(BaseToolWidget):
    """Advanced UI for the Web Application Vulnerability Scanner."""
    def __init__(self, settings, task_manager):
        super().__init__(settings, task_manager)
        self.engine = VulnerabilityScannerEngine(self.task_manager)

        # cache: {vuln_type: QTreeWidgetItem}
        self.vulnerability_items: Dict[str, QTreeWidgetItem] = {}
        # store findings: list of dicts from engine
        self.findings: List[dict] = []

        self._build_ui()
        self._connect_signals()
        self._apply_style()

    # ---------------- UI ----------------

    def _build_ui(self):
        main_layout = QVBoxLayout(self)

        # Toolbar actions
        self.toolbar = QToolBar()
        self.action_expand_all = QAction("Expand All", self)
        self.action_collapse_all = QAction("Collapse All", self)
        self.action_export_json = QAction("Export JSON", self)
        self.action_export_csv = QAction("Export CSV", self)

        self.toolbar.addAction(self.action_expand_all)
        self.toolbar.addAction(self.action_collapse_all)
        self.toolbar.addSeparator()
        self.toolbar.addAction(self.action_export_json)
        self.toolbar.addAction(self.action_export_csv)

        main_layout.addWidget(self.toolbar)

        # Tabs for Configuration / Results / Logs
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        # ---- Configuration Tab ----
        config_tab = QWidget()
        config_layout = QVBoxLayout(config_tab)

        config_group = QGroupBox("Scan Configuration")
        form = QFormLayout(config_group)

        self.target_input = QLineEdit("https://example.com")
        self.target_input.setPlaceholderText("https://target.tld")

        # Scan type checkboxes (keeps backward compatibility and lets you enable new engine plugins)
        self.scan_types_group = QGroupBox("Scan Types")
        scan_types_layout = QHBoxLayout(self.scan_types_group)
        self.sqli_checkbox = QCheckBox("SQL Injection")
        self.xss_checkbox = QCheckBox("Cross-Site Scripting (XSS)")
        self.open_redirect_checkbox = QCheckBox("Open Redirect")
        self.headers_checkbox = QCheckBox("Security Headers")
        self.cookies_checkbox = QCheckBox("Cookie Flags")
        self.csrf_checkbox = QCheckBox("CSRF (Heuristic)")

        # defaults
        self.sqli_checkbox.setChecked(True)
        self.xss_checkbox.setChecked(True)

        for cb in (
            self.sqli_checkbox, self.xss_checkbox, self.open_redirect_checkbox,
            self.headers_checkbox, self.cookies_checkbox, self.csrf_checkbox
        ):
            scan_types_layout.addWidget(cb)

        # Start/Stop buttons
        self.start_button = QPushButton("üöÄ Start Scan")
        self.stop_button = QPushButton("üõë Stop")
        self.stop_button.setEnabled(False)

        buttons = QHBoxLayout()
        buttons.addWidget(self.start_button)
        buttons.addWidget(self.stop_button)

        form.addRow("Target URL:", self.target_input)
        form.addRow(self.scan_types_group)
        form.addRow(buttons)

        config_layout.addWidget(config_group)
        self.tabs.addTab(config_tab, "‚öôÔ∏è Configuration")

        # ---- Results Tab ----
        results_tab = QWidget()
        results_layout = QVBoxLayout(results_tab)

        status_layout = QHBoxLayout()
        self.status_label = QLabel("Status: Idle")
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(False)
        # Busy/indeterminate mode; enabled during scan
        self.progress_bar.setRange(0, 0)
        self.progress_bar.setVisible(False)
        status_layout.addWidget(self.status_label, 2)
        status_layout.addWidget(self.progress_bar, 1)

        self.results_tree = QTreeWidget()
        self.results_tree.setColumnCount(2)
        self.results_tree.setHeaderLabels(["Vulnerability / Location", "Parameter / Payload"])
        self.results_tree.header().setStretchLastSection(True)
        self.results_tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.results_tree.customContextMenuRequested.connect(self._on_tree_context_menu)

        results_layout.addLayout(status_layout)
        results_layout.addWidget(self.results_tree)
        self.tabs.addTab(results_tab, "üìä Results")

        # ---- Logs Tab ----
        log_tab = QWidget()
        log_layout = QVBoxLayout(log_tab)
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)
        log_layout.addWidget(self.log_output)
        self.tabs.addTab(log_tab, "üìù Logs")

        # Toolbar connections
        self.action_expand_all.triggered.connect(self.results_tree.expandAll)
        self.action_collapse_all.triggered.connect(self.results_tree.collapseAll)
        self.action_export_json.triggered.connect(self._export_json)
        self.action_export_csv.triggered.connect(self._export_csv)

    def _apply_style(self):
        # Minimal darkish style (QSS). Tweak as desired.
        self.setStyleSheet("""
            QWidget { font-size: 12px; }
            QGroupBox {
                font-weight: 600;
                border: 1px solid #3c3f41;
                border-radius: 6px;
                margin-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top left;
                padding: 0 6px;
            }
            QTreeWidget {
                background: #111418;
                border: 1px solid #2a2e33;
            }
            QTextEdit {
                background: #0f1215;
                border: 1px solid #2a2e33;
            }
            QLabel { color: #e6e6e6; }
            QTabWidget::pane { border: 1px solid #2a2e33; }
            QTabBar::tab { padding: 6px 12px; }
            QProgressBar {
                background: #1c2025; border: 1px solid #3c3f41; height: 12px; border-radius: 6px;
            }
            QToolBar { border: 0; }
        """)

    # ------------- Connections -------------

    def _connect_signals(self):
        self.start_button.clicked.connect(self.start_scan)
        self.stop_button.clicked.connect(self.stop_scan)
        self.engine.vulnerability_found.connect(self.add_vulnerability)
        self.engine.progress_updated.connect(self.update_status)
        self.engine.scan_finished.connect(self.on_scan_finished)

    # ------------- Actions -------------

    def start_scan(self):
        base_url = self.target_input.text().strip()
        if not base_url:
            self.show_error("Target URL is required.")
            return

        scan_types = []
        if self.sqli_checkbox.isChecked():
            scan_types.append("sqli")
        if self.xss_checkbox.isChecked():
            scan_types.append("xss")
        if self.open_redirect_checkbox.isChecked():
            scan_types.append("open_redirect")
        if self.headers_checkbox.isChecked():
            scan_types.append("headers")
        if self.cookies_checkbox.isChecked():
            scan_types.append("cookies")
        if self.csrf_checkbox.isChecked():
            scan_types.append("csrf")

        if not scan_types:
            self.show_error("Please select at least one scan type.")
            return

        # Reset UI
        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)
        self.progress_bar.setVisible(True)
        self.results_tree.clear()
        self.vulnerability_items.clear()
        self.findings.clear()
        self.log_output.clear()
        self.status_label.setText("Status: Starting...")

        self.engine.start_scan(base_url, scan_types)

    def stop_scan(self):
        self.engine.stop_scan()
        self.log_output.append("üõë Scan stop requested by user.")

    def add_vulnerability(self, vuln_data: dict):
        """Append finding to tree + logs + cache for export."""
        self.findings.append(vuln_data)

        vuln_type = vuln_data.get("type", "Other")
        location = vuln_data.get("location", "")
        parameter = vuln_data.get("parameter", "")
        payload = vuln_data.get("payload", "")
        details = vuln_data.get("details", "")

        # Create a top-level category item if it doesn't exist
        if vuln_type not in self.vulnerability_items:
            parent_item = QTreeWidgetItem(self.results_tree, [vuln_type])
            parent_item.setForeground(0, self._color_for_type(vuln_type))
            self.vulnerability_items[vuln_type] = parent_item

        parent_item = self.vulnerability_items[vuln_type]
        second_col = self._format_second_col(parameter, payload, details)

        child = QTreeWidgetItem(parent_item, [f"Location: {location}", second_col])
        parent_item.setExpanded(True)

        # Log line
        log_line = f"[+] {vuln_type} at {location}"
        if parameter:
            log_line += f" | param={parameter}"
        if payload:
            log_line += f" | payload={payload}"
        if details:
            log_line += f" | details={details}"
        self.log_output.append(log_line)

    def update_status(self, message: str):
        self.status_label.setText(f"Status: {message}")
        # Put progress bar in busy mode during scan; no explicit % available from engine.
        if not self.progress_bar.isVisible():
            self.progress_bar.setVisible(True)
        self.log_output.append(f"[*] {message}")

    def on_scan_finished(self, message: str):
        self.status_label.setText(f"Status: {message}")
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        # End busy mode
        self.progress_bar.setVisible(False)
        self.log_output.append("‚úÖ Scan finished.")

        # Auto-switch to Results tab so findings are visible
        self.tabs.setCurrentIndex(1)

    def shutdown(self):
        self.stop_scan()

    # ------------- Helpers -------------

    def _color_for_type(self, vuln_type: str) -> QColor:
        """Simple severity coloring by type (tweak as needed)."""
        vt = vuln_type.lower()
        if "sql" in vt or "xss" in vt:
            return QColor("#ff5252")  # critical/high
        if "open redirect" in vt:
            return QColor("#ff9800")  # medium
        if "csrf" in vt:
            return QColor("#ffc107")  # medium/low
        if "header" in vt or "cookie" in vt:
            return QColor("#64b5f6")  # info
        return QColor("#eeeeee")

    def _format_second_col(self, parameter: str, payload: str, details: str) -> str:
        items = []
        if parameter:
            items.append(f"Param: {parameter}")
        if payload:
            items.append(f"Payload: {payload}")
        if details:
            items.append(f"Details: {details}")
        return " | ".join(items)

    # -------- Context Menu on Results --------

    def _on_tree_context_menu(self, pos: QPoint):
        item = self.results_tree.itemAt(pos)
        if not item:
            return
        menu = QMenu(self.results_tree)

        copy_row = QAction("Copy Row", self)
        copy_all = QAction("Copy All Findings (JSON)", self)
        export_json = QAction("Export JSON...", self)
        export_csv = QAction("Export CSV...", self)

        copy_row.triggered.connect(lambda: self._copy_item(item))
        copy_all.triggered.connect(self._copy_all_json)
        export_json.triggered.connect(self._export_json)
        export_csv.triggered.connect(self._export_csv)

        menu.addAction(copy_row)
        menu.addSeparator()
        menu.addAction(copy_all)
        menu.addSeparator()
        menu.addAction(export_json)
        menu.addAction(export_csv)
        menu.exec(self.results_tree.viewport().mapToGlobal(pos))

    def _copy_item(self, item: QTreeWidgetItem):
        text = f"{item.text(0)}  ||  {item.text(1)}"
        cb: QClipboard = self.results_tree.clipboard()
        cb.setText(text)

    def _copy_all_json(self):
        cb: QClipboard = self.results_tree.clipboard()
        cb.setText(json.dumps(self.findings, indent=2))
        QMessageBox.information(self, "Copied", "All findings copied to clipboard as JSON.")

    # -------- Export --------

    def _default_report_name(self, ext: str) -> str:
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"scan_report_{ts}.{ext}"

    def _export_json(self):
        if not self.findings:
            QMessageBox.warning(self, "No data", "There are no findings to export yet.")
            return
        path, _ = QFileDialog.getSaveFileName(self, "Export Findings as JSON",
                                              self._default_report_name("json"),
                                              "JSON Files (*.json);;All Files (*)")
        if not path:
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                json.dump(self.findings, f, indent=2, ensure_ascii=False)
            QMessageBox.information(self, "Exported", f"Findings saved to:\n{path}")
        except Exception as e:
            QMessageBox.critical(self, "Export Failed", str(e))

    def _export_csv(self):
        if not self.findings:
            QMessageBox.warning(self, "No data", "There are no findings to export yet.")
            return
        path, _ = QFileDialog.getSaveFileName(self, "Export Findings as CSV",
                                              self._default_report_name("csv"),
                                              "CSV Files (*.csv);;All Files (*)")
        if not path:
            return
        try:
            # Normalize keys
            fieldnames = ["type", "location", "parameter", "payload", "details"]
            with open(path, "w", encoding="utf-8", newline="") as f:
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()
                for row in self.findings:
                    writer.writerow({
                        "type": row.get("type", ""),
                        "location": row.get("location", ""),
                        "parameter": row.get("parameter", ""),
                        "payload": row.get("payload", ""),
                        "details": row.get("details", ""),
                    })
            QMessageBox.information(self, "Exported", f"Findings saved to:\n{path}")
        except Exception as e:
            QMessageBox.critical(self, "Export Failed", str(e))

